image: python:3.9.15

definitions:
  steps:
    - step: &branch-set-destination-head
        name: Destination Branch Set - HEAD
        script:
          - printf "HEAD" > destination_branch.txt
        artifacts:
          - destination_branch.txt
    - step: &branch-set-destination-pr-destination
        name: Destination Branch Set - PR Destination
        script:
          - printf "BITBUCKET_PR_DESTINATION_BRANCH" > destination_branch.txt
        artifacts:
          - destination_branch.txt
    - step: &branch-set-source-head
        name: Source Branch Set - HEAD
        script:
          - printf "HEAD" > source_branch.txt
        artifacts:
          - source_branch.txt
    - step: &branch-set-source-head-1
        name: Source Branch Set - HEAD~1
        script:
          - printf "HEAD~1" > source_branch.txt
        artifacts:
          - source_branch.txt
    - step: &build-fail-if-any-test-failures
        name: Fail Build if Any Test Failures
        script:
          # fail the build if any failures in xml unittest output folder
          - |
            if [ ! -z "$(ls -A tests-output)" ]; then
              for file in tests-output/*; do
                if [ "$(grep -c '<failure' "${file}")" -gt 0 ]; then
                  exit 1
                fi
              done
            fi
    - step: &check-dependencies-changed-bundles
        name: Check Bundles Dependencies Changed?
        condition:
          changesets:
            includePaths:
              - dependencies.json
        caches:
          - pip
        script:
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # check if global dependencies changed, if so use to skip step
          - |
            GLOBAL_DEPENDENCIES_UPDATED=`cat global_dependencies_diff.txt`
            if [ $GLOBAL_DEPENDENCIES_UPDATED == "true" ]; then
              exit 0
            fi
          # global dependencies unchanged, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install pip packages with --user flag to auto-cache
          - pip install --user -r requirements.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # list bundles
          - lambda_bundles=$(find ./lambda -mindepth 1 -maxdepth 1 -type d -printf '%f\n')
          # check if lambdas dependencies changed (add/remove)
          - |
            for lambda_bundle in $lambda_bundles; do
              lambda_names=$(python -m arcimoto_lambda_utility list --bundle $lambda_bundle)
              git -c advice.detachedHead=false checkout $DESTINATION_BRANCH
              for lambda_name in $lambda_names; do
                python -m arcimoto_lambda_utility dependencies $lambda_name > ${lambda_name}_dependencies_destination.txt
              done
              git -c advice.detachedHead=false checkout $BITBUCKET_BRANCH
              for lambda_name in $lambda_names; do
                python -m arcimoto_lambda_utility dependencies $lambda_name > ${lambda_name}_dependencies_source.txt
              done
              for lambda_name in $lambda_names; do
                dependencies_changed=$(comm -3 ${lambda_name}_dependencies_destination.txt ${lambda_name}_dependencies_source.txt)
                if [ ! -z "$dependencies_changed" ]; then
                  echo "$lambda_name" >> updates/dependencies_changed_${lambda_bundle}.txt
                fi
              done
            done
        artifacts:
          - updates/**
    - step: &check-dependencies-changed-global
        name: Check if Global Dependencies Changed?
        caches:
          - pip
        script:
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # BITBUCKET_BRANCH is source branch
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              if [ $BITBUCKET_BRANCH == "staging" ]; then
                DESTINATION_BRANCH="origin/master"
              else
                DESTINATION_BRANCH="origin/staging"
              fi
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # check if global dependencies submodule has updates in this branch
          # get hash for source branch submodule
          - source_branch_submodule_hash=$(git submodule status dependencies/arcimoto | awk '{print $1}')
          # get hash for destination branch submodule
          - git checkout -b $DESTINATION_BRANCH
          - destination_branch_submodule_hash=$(git submodule status dependencies/arcimoto | awk '{print $1}')
          # note if global dependencies hash changed in file for future steps to access
          # if not changed then skip rest of step
          - |
            if [ $source_branch_submodule_hash == $destination_branch_submodule_hash ]; then
              printf "false" > global_dependencies_diff.txt
              exit 0
            else
              printf "true" > global_dependencies_diff.txt
            fi
          # list bundles
          - lambda_bundles=$(find ./lambda -mindepth 1 -maxdepth 1 -type d -printf '%f\n')
          # output all lambdas in each bundle to discreet file
          - |
            for lambda_bundle in $lambda_bundles; do
              lambdas=$(python -m arcimoto_lambda_utility list --bundle $lambda_bundle)
              printf "%s\n" $lambdas > updates/lambdas_updated_${lambda_bundle}.txt
            done
        artifacts:
          - global_dependencies_diff.txt
          - updates/**
    - step: &check-dependencies-updated-bundles
        name: Check Bundles Dependencies Updated?
        caches:
          - pip
        script:
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install pip packages with --user flag to auto-cache
          - pip install --user -r requirements.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # list bundles
          - lambda_bundles=$(find ./lambda -mindepth 1 -maxdepth 1 -type d -printf '%f\n')
          # check if any lambdas in bundle had dependencies updated - excludes updates files
          - |
            for lambda_bundle in $lambda_bundles; do
              lambda_names=$(python -m arcimoto_lambda_utility list --bundle $lambda_bundle)
              for lambda_name in $lambda_names; do
                lambda_dependencies=$(python -m arcimoto_lambda_utility dependencies $lambda_name)
                for lambda_dependency in $lambda_dependencies; do
                  lambda_dependency_updated=$(git diff --name-only $SOURCE_BRANCH $DESTINATION_BRANCH -- $lambda_dependency)
                  if [ ! -z "$lambda_dependency_updated" ]; then
                    echo "$lambda_name" >> updates/dependencies_updated_${lambda_bundle}.txt
                    break
                  fi
                done
              done
            done
        artifacts:
          - updates/**
    - step: &dependencies-changed-global
        name: Global Dependencies Changed
        caches:
          - pip
        script:
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install pip packages with --user flag to auto-cache
          - pip install --user -r requirements.txt
          # note global dependencies changed, in file for future steps to access
          - printf "true" > global_dependencies_diff.txt
          # list bundles
          - lambda_bundles=$(find ./lambda -mindepth 1 -maxdepth 1 -type d -printf '%f\n')
          # output all lambdas in each bundle to discreet file
          - |
            for lambda_bundle in $lambda_bundles; do
              lambdas=$(python -m arcimoto_lambda_utility list --bundle $lambda_bundle)
              printf "%s\n" $lambdas > updates/lambdas_updated_${lambda_bundle}.txt
            done
        artifacts:
          - global_dependencies_diff.txt
          - updates/**
    - step: &email-release-complete-dev
        name: Send Completion Email - Dev Release
        caches:
          - docker
        script:
          - email=$(git log --format='%ae' ${BITBUCKET_COMMIT}^!)
          - BB_LINK="https://bitbucket.org/${BITBUCKET_WORKSPACE}/${BITBUCKET_REPO_SLUG}/"
          - HEADER="#AWS Lambda Deploy to Dev Complete"
          - CONTENT="The pipeline for a merge to the \`dev\` branch for the \`awslambda\` repo has completed. See the attached file \`lambda_to_update.txt\` for a list of effected lambdas."
          - BUILD_LINK="[Pipeline Execution ${BITBUCKET_BUILD_NUMBER}](${BB_LINK}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER})"
          - printf "$HEADER\n\n$CONTENT\n\n$BUILD_LINK" | docker run -i datafolklabs/markdown > email_body.html
          - pipe: atlassian/email-notify:0.6.0
            variables:
              USERNAME: $SES_SMTP_USERNAME
              PASSWORD: $SES_SMTP_PASSWORD
              FROM: no-reply@arcimoto.com
              TO: $email
              SUBJECT: AWS Lambda - Deploy to Dev Complete
              HOST: email-smtp.us-west-2.amazonaws.com
              BODY_HTML: email_body.html
              ATTACHMENTS: lambdas_updated.txt
    - step: &email-release-complete-prod
        name: Send Completion Email - Production Release
        caches:
          - docker
        script:
          - email=$(git log --format='%ae' ${BITBUCKET_COMMIT}^!)
          - BB_LINK="https://bitbucket.org/${BITBUCKET_WORKSPACE}/${BITBUCKET_REPO_SLUG}/"
          - HEADER="#AWS Lambda Release to Production Complete"
          - CONTENT="The pipeline for a merge to the \`master\` branch for the \`awslambda\` repo has completed. See the attached file \`lambda_to_update.txt\` for a list of effected lambdas."
          - BUILD_LINK="[Pipeline Execution ${BITBUCKET_BUILD_NUMBER}](${BB_LINK}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER})"
          - printf "$HEADER\n\n$CONTENT\n\n$BUILD_LINK" | docker run -i datafolklabs/markdown > email_body.html
          - pipe: atlassian/email-notify:0.6.0
            variables:
              USERNAME: $SES_SMTP_USERNAME
              PASSWORD: $SES_SMTP_PASSWORD
              FROM: no-reply@arcimoto.com
              TO: $email
              SUBJECT: AWS Lambda - Release to Production Complete
              HOST: email-smtp.us-west-2.amazonaws.com
              BODY_HTML: email_body.html
              ATTACHMENTS: lambdas_updated.txt
    - step: &email-release-complete-staging
        name: Send Completion Email - Staging Release
        caches:
          - docker
        script:
          - email=$(git log --format='%ae' ${BITBUCKET_COMMIT}^!)
          - BB_LINK="https://bitbucket.org/${BITBUCKET_WORKSPACE}/${BITBUCKET_REPO_SLUG}/"
          - HEADER="#AWS Lambda Release to Staging Complete"
          - CONTENT="The pipeline for a merge to the \`staging\` branch for the \`awslambda\` repo has completed. See the attached file \`lambda_to_update.txt\` for a list of effected lambdas."
          - BUILD_LINK="[Pipeline Execution ${BITBUCKET_BUILD_NUMBER}](${BB_LINK}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER})"
          - printf "$HEADER\n\n$CONTENT\n\n$BUILD_LINK" | docker run -i datafolklabs/markdown > email_body.html
          - pipe: atlassian/email-notify:0.6.0
            variables:
              USERNAME: $SES_SMTP_USERNAME
              PASSWORD: $SES_SMTP_PASSWORD
              FROM: no-reply@arcimoto.com
              TO: $email
              SUBJECT: AWS Lambda - Release to Staging Complete
              HOST: email-smtp.us-west-2.amazonaws.com
              BODY_HTML: email_body.html
              ATTACHMENTS: lambdas_updated.txt
    - step: &email-tests-complete
        name: Send Tests Completion Email
        caches:
          - docker
        script:
          # count failures
          - failures=0
          - |
            for file in tests-output/*; do
              failures=$((failures+"$(grep -l '<failure' "${file}" | wc -l)"))
            done
          # create email pieces
          - SUBJECT="AWS Lambda - Tests Complete for Pull Request ${BITBUCKET_PR_ID} - "
          - email=$(git log --format='%ae' ${BITBUCKET_COMMIT}^!)
          - HEADER="#AWS Lambda Tests Complete - "
          - |
            if [ "$failures" -eq "0" ]; then
              SUBJECT="${SUBJECT}Success"
              HEADER="${HEADER}Success"
            else
              SUBJECT="${SUBJECT}Failure"
              HEADER="${HEADER}Failure"
            fi
          - CONTENT="The pipeline running tests for the \`awslambda\` repo has completed."
          - FAILURES="###Test Failures - ${failures}"
          - BB_LINK="https://bitbucket.org/${BITBUCKET_WORKSPACE}/${BITBUCKET_REPO_SLUG}/"
          - BUILD_LINK="- [Pipeline Execution ${BITBUCKET_BUILD_NUMBER}](${BB_LINK}/addon/pipelines/home#!/results/${BITBUCKET_BUILD_NUMBER})"
          - PR_LINK="- [Pull Request ${BITBUCKET_PR_ID}](${BB_LINK}/pull-requests/${BITBUCKET_PR_ID})"
          # assemble pieces into email
          - printf "$HEADER\n\n$CONTENT\n\n$FAILURES\n\n$BUILD_LINK\n$PR_LINK" | docker run -i datafolklabs/markdown > email_body.html
          # send email
          - pipe: atlassian/email-notify:0.6.0
            variables:
              USERNAME: $SES_SMTP_USERNAME
              PASSWORD: $SES_SMTP_PASSWORD
              FROM: no-reply@arcimoto.com
              TO: $email
              SUBJECT: $SUBJECT
              HOST: email-smtp.us-west-2.amazonaws.com
              BODY_HTML: email_body.html
              ATTACHMENTS: lambdas_updated.txt
    - step: &lambdas-deploy-all-bundle-alarms
        name: Deploy All Lambdas in Bundle (alarms)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=alarms
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install pip packages with --user flag to auto-cache
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-authorities
        name: Deploy All Lambdas in Bundle (authorities)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=authorities
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install pip packages with --user flag to auto-cache
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-backfill
        name: Deploy All Lambdas in Bundle (backfill)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=backfill
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install pip packages with --user flag to auto-cache
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-debug
        name: Deploy All Lambdas in Bundle (debug)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=debug
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-firmware
        name: Deploy All Lambdas in Bundle (firmware)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=firmware
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-fleets
        name: Deploy All Lambdas in Bundle (fleets)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=fleets
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-grafana
        name: Deploy All Lambdas in Bundle (grafana)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=grafana
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-hologram
        name: Deploy All Lambdas in Bundle (hologram)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=hologram
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-locations
        name: Deploy All Lambdas in Bundle (locations)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=locations
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-managed_session
        name: Deploy All Lambdas in Bundle (managed_session)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=managed_session
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-notes
        name: Deploy All Lambdas in Bundle (notes)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=notes
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-orders
        name: Deploy All Lambdas in Bundle (orders)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=orders
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-recalls
        name: Deploy All Lambdas in Bundle (recalls)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=recalls
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-reef
        name: Deploy All Lambdas in Bundle (reef)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=reef
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-replicate
        name: Deploy All Lambdas in Bundle (replicate)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=replicate
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-sheer_id
        name: Deploy All Lambdas in Bundle (sheer_id)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=sheer_id
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-telemetry
        name: Deploy All Lambdas in Bundle (telemetry)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=telemetry
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-unit_test
        name: Deploy All Lambdas in Bundle (unit_test)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=unit_test
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-userpool
        name: Deploy All Lambdas in Bundle (userpool)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=userpool
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-users
        name: Deploy All Lambdas in Bundle (users)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=users
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-utility
        name: Deploy All Lambdas in Bundle (utility)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=utility
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-vehicles
        name: Deploy All Lambdas in Bundle (vehicles)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=vehicles
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-all-bundle-yrisk
        name: Deploy All Lambdas in Bundle (yrisk)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=yrisk
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # deploy all lambdas from bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              python -m arcimoto_lambda_utility update $lambda_name
            done
    - step: &lambdas-deploy-changed-bundle-alarms
        name: Deploy Changed Lambdas in Bundle (alarms)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=alarms
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-authorities
        name: Deploy Changed Lambdas in Bundle (authorities)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=authorities
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-backfill
        name: Deploy Changed Lambdas in Bundle (backfill)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=backfill
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-debug
        name: Deploy Changed Lambdas in Bundle (debug)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=debug
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-firmware
        name: Deploy Changed Lambdas in Bundle (firmware)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=firmware
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-fleets
        name: Deploy Changed Lambdas in Bundle (fleets)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=fleets
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-grafana
        name: Deploy Changed Lambdas in Bundle (grafana)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=grafana
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-hologram
        name: Deploy Changed Lambdas in Bundle (hologram)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=hologram
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-locations
        name: Deploy Changed Lambdas in Bundle (locations)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=locations
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-managed_session
        name: Deploy Changed Lambdas in Bundle (managed_session)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=managed_session
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-notes
        name: Deploy Changed Lambdas in Bundle (notes)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=notes
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-orders
        name: Deploy Changed Lambdas in Bundle (orders)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=orders
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-recalls
        name: Deploy Changed Lambdas in Bundle (recalls)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=recalls
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-reef
        name: Deploy Changed Lambdas in Bundle (reef)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=reef
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-replicate
        name: Deploy Changed Lambdas in Bundle (replicate)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=replicate
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-sheer_id
        name: Deploy Changed Lambdas in Bundle (sheer_id)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=sheer_id
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-telemetry
        name: Deploy Changed Lambdas in Bundle (telemetry)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=telemetry
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-unit_test
        name: Deploy Changed Lambdas in Bundle (unit_test)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=unit_test
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-userpool
        name: Deploy Changed Lambdas in Bundle (userpool)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=userpool
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-users
        name: Deploy Changed Lambdas in Bundle (users)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=users
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-utility
        name: Deploy Changed Lambdas in Bundle (utility)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=utility
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-vehicles
        name: Deploy Changed Lambdas in Bundle (vehicles)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=vehicles
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-deploy-changed-bundle-yrisk
        name: Deploy Changed Lambdas in Bundle (yrisk)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=yrisk
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility update $line
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-alarms
        name: Release Lambda Bundle [staging] (alarms)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=alarms
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-authorities
        name: Release Lambda Bundle [staging] (authorities)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=authorities
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-backfill
        name: Release Lambda Bundle [staging] (backfill)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=backfill
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-debug
        name: Release Lambda Bundle [staging] (debug)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=debug
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-firmware
        name: Release Lambda Bundle [staging] (firmware)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=firmware
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-fleets
        name: Release Lambda Bundle [staging] (fleets)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=fleets
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-grafana
        name: Release Lambda Bundle [staging] (grafana)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=grafana
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-hologram
        name: Release Lambda Bundle [staging] (hologram)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=hologram
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-locations
        name: Release Lambda Bundle [staging] (locations)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=locations
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-managed_session
        name: Release Lambda Bundle [staging] (managed_session)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=managed_session
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-notes
        name: Release Lambda Bundle [staging] (notes)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=notes
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-orders
        name: Release Lambda Bundle [staging] (orders)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=orders
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-recalls
        name: Release Lambda Bundle [staging] (recalls)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=recalls
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-reef
        name: Release Lambda Bundle [staging] (reef)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=reef
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-replicate
        name: Release Lambda Bundle [staging] (replicate)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=replicate
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-sheer_id
        name: Release Lambda Bundle [staging] (sheer_id)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=sheer_id
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-telemetry
        name: Release Lambda Bundle [staging] (telemetry)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=telemetry
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-unit_test
        name: Release Lambda Bundle [staging] (unit_test)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=unit_test
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-userpool
        name: Release Lambda Bundle [staging] (userpool)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=userpool
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-users
        name: Release Lambda Bundle [staging] (users)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=users
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-utility
        name: Release Lambda Bundle [staging] (utility)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=utility
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-vehicles
        name: Release Lambda Bundle [staging] (vehicles)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=vehicles
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-staging-bundle-yrisk
        name: Release Lambda Bundle [staging] (yrisk)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=yrisk
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line staging
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-alarms
        name: Release Lambda Bundle [prod] (alarms)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=alarms
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-authorities
        name: Release Lambda Bundle [prod] (authorities)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=authorities
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-backfill
        name: Release Lambda Bundle [prod] (backfill)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=backfill
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-debug
        name: Release Lambda Bundle [prod] (debug)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=debug
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-firmware
        name: Release Lambda Bundle [prod] (firmware)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=firmware
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-fleets
        name: Release Lambda Bundle [prod] (fleets)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=fleets
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-grafana
        name: Release Lambda Bundle [prod] (grafana)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=grafana
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-hologram
        name: Release Lambda Bundle [prod] (hologram)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=hologram
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-locations
        name: Release Lambda Bundle [prod] (locations)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=locations
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-managed_session
        name: Release Lambda Bundle [prod] (managed_session)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=managed_session
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-notes
        name: Release Lambda Bundle [prod] (notes)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=notes
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-orders
        name: Release Lambda Bundle [prod] (orders)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=orders
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-recalls
        name: Release Lambda Bundle [prod] (recalls)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=recalls
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-reef
        name: Release Lambda Bundle [prod] (reef)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=reef
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-replicate
        name: Release Lambda Bundle [prod] (replicate)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=replicate
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-sheer_id
        name: Release Lambda Bundle [prod] (sheer_id)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=sheer_id
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-telemetry
        name: Release Lambda Bundle [prod] (telemetry)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=telemetry
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-unit_test
        name: Release Lambda Bundle [prod] (unit_test)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=unit_test
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-userpool
        name: Release Lambda Bundle [prod] (userpool)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=userpool
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-users
        name: Release Lambda Bundle [prod] (users)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=users
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-utility
        name: Release Lambda Bundle [prod] (utility)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=utility
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-vehicles
        name: Release Lambda Bundle [prod] (vehicles)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=vehicles
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-release-prod-bundle-yrisk
        name: Release Lambda Bundle [prod] (yrisk)
        caches:
          - pip
        script:
          # set bundle
          - BUNDLE=yrisk
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # deploy lambdas that were updated
          - |
            while IFS= read -r line; do
              python -m arcimoto_lambda_utility release $line prod
            done < lambdas_updated.txt
    - step: &lambdas-updated-bundle-alarms
        name: Bundle Lambdas Updated? (alarms)
        condition:
          changesets:
            includePaths:
              - lambda/alarms/**
        caches:
          - pip
        script:
          - BUNDLE=alarms
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-authorities
        name: Bundle Lambdas Updated? (authorities)
        condition:
          changesets:
            includePaths:
              - lambda/authorities/**
        caches:
          - pip
        script:
          - BUNDLE=authorities
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-backfill
        name: Bundle Lambdas Updated? (backfill)
        condition:
          changesets:
            includePaths:
              - lambda/backfill/**
        caches:
          - pip
        script:
          - BUNDLE=backfill
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-debug
        name: Bundle Lambdas Updated? (debug)
        condition:
          changesets:
            includePaths:
              - lambda/debug/**
        caches:
          - pip
        script:
          - BUNDLE=debug
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-firmware
        name: Bundle Lambdas Updated? (firmware)
        condition:
          changesets:
            includePaths:
              - lambda/firmware/**
        caches:
          - pip
        script:
          - BUNDLE=firmware
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-fleets
        name: Bundle Lambdas Updated? (fleets)
        condition:
          changesets:
            includePaths:
              - lambda/fleets/**
        caches:
          - pip
        script:
          - BUNDLE=fleets
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-grafana
        name: Bundle Lambdas Updated? (grafana)
        condition:
          changesets:
            includePaths:
              - lambda/grafana/**
        caches:
          - pip
        script:
          - BUNDLE=grafana
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-hologram
        name: Bundle Lambdas Updated? (hologram)
        condition:
          changesets:
            includePaths:
              - lambda/hologram/**
        caches:
          - pip
        script:
          - BUNDLE=hologram
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-locations
        name: Bundle Lambdas Updated? (locations)
        condition:
          changesets:
            includePaths:
              - lambda/locations/**
        caches:
          - pip
        script:
          - BUNDLE=locations
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-managed_session
        name: Bundle Lambdas Updated? (managed_session)
        condition:
          changesets:
            includePaths:
              - lambda/managed_session/**
        caches:
          - pip
        script:
          - BUNDLE=managed_session
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-notes
        name: Bundle Lambdas Updated? (notes)
        condition:
          changesets:
            includePaths:
              - lambda/notes/**
        caches:
          - pip
        script:
          - BUNDLE=notes
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-orders
        name: Bundle Lambdas Updated? (orders)
        condition:
          changesets:
            includePaths:
              - lambda/orders/**
        caches:
          - pip
        script:
          - BUNDLE=orders
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-recalls
        name: Bundle Lambdas Updated? (recalls)
        condition:
          changesets:
            includePaths:
              - lambda/recalls/**
        caches:
          - pip
        script:
          - BUNDLE=recalls
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-reef
        name: Bundle Lambdas Updated? (reef)
        condition:
          changesets:
            includePaths:
              - lambda/reef/**
        caches:
          - pip
        script:
          - BUNDLE=reef
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-replicate
        name: Bundle Lambdas Updated? (replicate)
        condition:
          changesets:
            includePaths:
              - lambda/replicate/**
        caches:
          - pip
        script:
          - BUNDLE=replicate
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-sheer_id
        name: Bundle Lambdas Updated? (sheer_id)
        condition:
          changesets:
            includePaths:
              - lambda/sheer_id/**
        caches:
          - pip
        script:
          - BUNDLE=sheer_id
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-telemetry
        name: Bundle Lambdas Updated? (telemetry)
        condition:
          changesets:
            includePaths:
              - lambda/telemetry/**
        caches:
          - pip
        script:
          - BUNDLE=telemetry
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-unit_test
        name: Bundle Lambdas Updated? (unit_test)
        condition:
          changesets:
            includePaths:
              - lambda/unit_test/**
        caches:
          - pip
        script:
          - BUNDLE=unit_test
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-userpool
        name: Bundle Lambdas Updated? (userpool)
        condition:
          changesets:
            includePaths:
              - lambda/userpool/**
        caches:
          - pip
        script:
          - BUNDLE=userpool
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-users
        name: Bundle Lambdas Updated? (users)
        condition:
          changesets:
            includePaths:
              - lambda/users/**
        caches:
          - pip
        script:
          - BUNDLE=users
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-utility
        name: Bundle Lambdas Updated? (utility)
        condition:
          changesets:
            includePaths:
              - lambda/utility/**
        caches:
          - pip
        script:
          - BUNDLE=utility
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-vehicles
        name: Bundle Lambdas Updated? (vehicles)
        condition:
          changesets:
            includePaths:
              - lambda/vehicles/**
        caches:
          - pip
        script:
          - BUNDLE=vehicles
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &lambdas-updated-bundle-yrisk
        name: Bundle Lambdas Updated? (yrisk)
        condition:
          changesets:
            includePaths:
              - lambda/yrisk/**
        caches:
          - pip
        script:
          - BUNDLE=yrisk
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f updates/pipeline_init.txt
          # read source branch from file into variable
          - SOURCE_BRANCH=`cat source_branch.txt`
          # read destination branch from file into variable
          # use $BITBUCKET_PR_DESTINATION_BRANCH when feature branch (during tests run on PR to dev)
          - |
            if grep -Fxq BITBUCKET_PR_DESTINATION_BRANCH destination_branch.txt; then
              DESTINATION_BRANCH=origin/${BITBUCKET_PR_DESTINATION_BRANCH}
            else
              DESTINATION_BRANCH=`cat destination_branch.txt`
            fi
          # pull in git destination branch
          - git fetch origin "+refs/heads/*:refs/remotes/origin/*"
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # get the lambda files from bundle changed in the last commit
          - files=$(git diff --name-only --diff-filter=d $SOURCE_BRANCH $DESTINATION_BRANCH -- lambda/${BUNDLE}/*)
          # gets filenames without extensions and adds to updated
          - |
            for file in $files; do
              filenameext=$(basename -- $file)
              lambda="${filenameext%.*}"
              echo "$lambda" >> updates/lambdas_updated_${BUNDLE}.txt
            done
        artifacts:
          - updates/**
    - step: &output-file-create
        name: Create Output File
        script:
          - cat updates/* > lambdas_updated.txt
          - sort -o lambdas_updated.txt lambdas_updated.txt | uniq
        artifacts:
          - lambdas_updated.txt
    - step: &ses-update-template-orders-success-customer-dev
        name: SES - Update Template [dev] - Orders - Success - Customer
        condition:
          changesets:
            includePaths:
              - utility/ses/templates/*/TEL_orders_order_success_customer*
        caches:
          - pip
        script:
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          - cd utility/ses/templates
          - python -m arcimoto_ses_utility template_upsert TEL_orders_order_success_customer_dev --content-file-path-html html/TEL_orders_order_success_customer.html --content-file-path-text text/TEL_orders_order_success_customer.txt
    - step: &ses-update-template-orders-success-customer-prod
        name: SES - Update Template [prod] - Orders - Success - Customer
        condition:
          changesets:
            includePaths:
              - utility/ses/templates/*/TEL_orders_order_success_customer*
        caches:
          - pip
        script:
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          - cd utility/ses/templates
          - python -m arcimoto_ses_utility template_upsert TEL_orders_order_success_customer_prod --content-file-path-html html/TEL_orders_order_success_customer.html --content-file-path-text text/TEL_orders_order_success_customer.txt
    - step: &ses-update-template-orders-success-customer-staging
        name: SES - Update Template [staging] - Orders - Success - Customer
        condition:
          changesets:
            includePaths:
              - utility/ses/templates/*/TEL_orders_order_success_customer*
        caches:
          - pip
        script:
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          - cd utility/ses/templates
          - python -m arcimoto_ses_utility template_upsert TEL_orders_order_success_customer_staging --content-file-path-html html/TEL_orders_order_success_customer.html --content-file-path-text text/TEL_orders_order_success_customer.txt
    - step: &ses-update-template-orders-success-cx-dev
        name: SES - Update Template [dev] - Orders - Success - CX
        condition:
          changesets:
            includePaths:
              - utility/ses/templates/*/TEL_orders_order_success_CX*
        caches:
          - pip
        script:
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          - cd utility/ses/templates
          - python -m arcimoto_ses_utility template_upsert TEL_orders_order_success_CX_dev --content-file-path-html html/TEL_orders_order_success_CX.html --content-file-path-text text/TEL_orders_order_success_CX.txt
    - step: &ses-update-template-orders-success-cx-prod
        name: SES - Update Template [prod] - Orders - Success - CX
        condition:
          changesets:
            includePaths:
              - utility/ses/templates/*/TEL_orders_order_success_CX*
        caches:
          - pip
        script:
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          - cd utility/ses/templates
          - python -m arcimoto_ses_utility template_upsert TEL_orders_order_success_CX_prod --content-file-path-html html/TEL_orders_order_success_CX.html --content-file-path-text text/TEL_orders_order_success_CX.txt
    - step: &ses-update-template-orders-success-cx-staging
        name: SES - Update Template [staging] - Orders - Success - CX
        condition:
          changesets:
            includePaths:
              - utility/ses/templates/*/TEL_orders_order_success_CX*
        caches:
          - pip
        script:
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          - cd utility/ses/templates
          - python -m arcimoto_ses_utility template_upsert TEL_orders_order_success_CX_staging --content-file-path-html html/TEL_orders_order_success_CX.html --content-file-path-text text/TEL_orders_order_success_CX.txt
    - step: &structure-create-tests
        name: Tests - Create Structure
        script:
          - mkdir test-reports
          # create file to force folder to become artifact available for next steps
          - touch test-reports/pipeline_init.txt
        artifacts:
            - test-reports/**
    - step: &structure-create-diffs
        name: Diffs - Create Structure
        script:
          - mkdir updates
          # create file to force folder to become artifact available for next steps
          - touch updates/pipeline_init.txt
        artifacts:
          - updates/**
    - step: &tests-dependencies-json
        name: Dependencies and Schema Files - Validity Tests
        condition:
          changesets:
            includePaths:
              - dependencies*.json
        caches:
          - pip
        script:
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests
          - python -m arcimoto_lambda_utility test None --test-dependencies-file-exists --output-xml
          - python -m arcimoto_lambda_utility test None --test-dependencies-schema-exists --output-xml
          - python -m arcimoto_lambda_utility test None --test-dependencies-file-valid-json --output-xml
          - python -m arcimoto_lambda_utility test None --test-dependencies-schema-valid-json --output-xml
          - python -m arcimoto_lambda_utility test None --test-dependencies-file-valid-for-schema --output-xml
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-lambda-definitions
        name: Lambda Definitions Test Suite
        condition:
          changesets:
            includePaths:
              - dependencies.json
              - lambda/**/bundle.json
        caches:
          - pip
        script:
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          - python -m arcimoto_lambda_utility test None --test-lambda-definitions --output-xml
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-alarms
        name: Run All Unit Tests - Bundle (alarms)
        caches:
          - pip
        script:
          - BUNDLE=alarms
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-authorities
        name: Run All Unit Tests - Bundle (authorities)
        caches:
          - pip
        script:
          - BUNDLE=authorities
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-backfill
        name: Run All Unit Tests - Bundle (backfill)
        caches:
          - pip
        script:
          - BUNDLE=backfill
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-debug
        name: Run All Unit Tests - Bundle (debug)
        caches:
          - pip
        script:
          - BUNDLE=debug
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-firmware
        name: Run All Unit Tests - Bundle (firmware)
        caches:
          - pip
        script:
          - BUNDLE=firmware
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-fleets
        name: Run All Unit Tests - Bundle (fleets)
        caches:
          - pip
        script:
          - BUNDLE=fleets
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-grafana
        name: Run All Unit Tests - Bundle (grafana)
        caches:
          - pip
        script:
          - BUNDLE=grafana
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-hologram
        name: Run All Unit Tests - Bundle (hologram)
        caches:
          - pip
        script:
          - BUNDLE=hologram
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-locations
        name: Run All Unit Tests - Bundle (locations)
        caches:
          - pip
        script:
          - BUNDLE=locations
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-managed_session
        name: Run All Unit Tests - Bundle (managed_session)
        caches:
          - pip
        script:
          - BUNDLE=managed_session
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-notes
        name: Run All Unit Tests - Bundle (notes)
        caches:
          - pip
        script:
          - BUNDLE=notes
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-orders
        name: Run All Unit Tests - Bundle (orders)
        caches:
          - pip
        script:
          - BUNDLE=orders
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-recalls
        name: Run All Unit Tests - Bundle (recalls)
        caches:
          - pip
        script:
          - BUNDLE=recalls
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-reef
        name: Run All Unit Tests - Bundle (reef)
        caches:
          - pip
        script:
          - BUNDLE=reef
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-replicate
        name: Run All Unit Tests - Bundle (replicate)
        caches:
          - pip
        script:
          - BUNDLE=replicate
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-sheer_id
        name: Run All Unit Tests - Bundle (sheer_id)
        caches:
          - pip
        script:
          - BUNDLE=sheer_id
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-telemetry
        name: Run All Unit Tests - Bundle (telemetry)
        caches:
          - pip
        script:
          - BUNDLE=telemetry
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-unit_test
        name: Run All Unit Tests - Bundle (unit_test)
        caches:
          - pip
        script:
          - BUNDLE=unit_test
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-userpool
        name: Run All Unit Tests - Bundle (userpool)
        caches:
          - pip
        script:
          - BUNDLE=userpool
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-users
        name: Run All Unit Tests - Bundle (users)
        caches:
          - pip
        script:
          - BUNDLE=users
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-utility
        name: Run All Unit Tests - Bundle (utility)
        caches:
          - pip
        script:
          - BUNDLE=utility
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-vehicles
        name: Run All Unit Tests - Bundle (vehicles)
        caches:
          - pip
        script:
          - BUNDLE=vehicles
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-all-bundle-yrisk
        name: Run All Unit Tests - Bundle (yrisk)
        caches:
          - pip
        script:
          - BUNDLE=yrisk
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # run tests for all lambdas in bundle
          - |
            for lambda_name in $(python -m arcimoto_lambda_utility list --bundle $BUNDLE); do
              if [[ $lambda_name == test_* ]]; then
                :
              else
                python -m arcimoto_lambda_utility test $lambda_name --output-xml
              fi
            done
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-alarms
        name:  Run Changed Unit Tests - Bundle (alarms)
        caches:
          - pip
        script:
          - BUNDLE=alarms
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-authorities
        name:  Run Changed Unit Tests - Bundle (authorities)
        caches:
          - pip
        script:
          - BUNDLE=authorities
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                 python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-backfill
        name:  Run Changed Unit Tests - Bundle (backfill)
        caches:
          - pip
        script:
          - BUNDLE=backfill
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-debug
        name:  Run Changed Unit Tests - Bundle (debug)
        caches:
          - pip
        script:
          - BUNDLE=debug
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-firmware
        name:  Run Changed Unit Tests - Bundle (firmware)
        caches:
          - pip
        script:
          - BUNDLE=firmware
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-fleets
        name:  Run Changed Unit Tests - Bundle (fleets)
        caches:
          - pip
        script:
          - BUNDLE=fleets
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-grafana
        name:  Run Changed Unit Tests - Bundle (grafana)
        caches:
          - pip
        script:
          - BUNDLE=grafana
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-hologram
        name:  Run Changed Unit Tests - Bundle (hologram)
        caches:
          - pip
        script:
          - BUNDLE=hologram
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-locations
        name:  Run Changed Unit Tests - Bundle (locations)
        caches:
          - pip
        script:
          - BUNDLE=locations
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-managed_session
        name:  Run Changed Unit Tests - Bundle (managed_session)
        caches:
          - pip
        script:
          - BUNDLE=managed_session
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-notes
        name:  Run Changed Unit Tests - Bundle (notes)
        caches:
          - pip
        script:
          - BUNDLE=notes
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-orders
        name:  Run Changed Unit Tests - Bundle (orders)
        caches:
          - pip
        script:
          - BUNDLE=orders
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-recalls
        name:  Run Changed Unit Tests - Bundle (recalls)
        caches:
          - pip
        script:
          - BUNDLE=recalls
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-reef
        name:  Run Changed Unit Tests - Bundle (reef)
        caches:
          - pip
        script:
          - BUNDLE=reef
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-replicate
        name:  Run Changed Unit Tests - Bundle (replicate)
        caches:
          - pip
        script:
          - BUNDLE=replicate
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-sheer_id
        name:  Run Changed Unit Tests - Bundle (sheer_id)
        caches:
          - pip
        script:
          - BUNDLE=sheer_id
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-telemetry
        name:  Run Changed Unit Tests - Bundle (telemetry)
        caches:
          - pip
        script:
          - BUNDLE=telemetry
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-unit_test
        name:  Run Changed Unit Tests - Bundle (unit_test)
        caches:
          - pip
        script:
          - BUNDLE=unit_test
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-userpool
        name:  Run Changed Unit Tests - Bundle (userpool)
        caches:
          - pip
        script:
          - BUNDLE=userpool
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-users
        name:  Run Changed Unit Tests - Bundle (users)
        caches:
          - pip
        script:
          - BUNDLE=users
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-utility
        name:  Run Changed Unit Tests - Bundle (utility)
        caches:
          - pip
        script:
          - BUNDLE=utility
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-vehicles
        name:  Run Changed Unit Tests - Bundle (vehicles)
        caches:
          - pip
        script:
          - BUNDLE=vehicles
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run all parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**
    - step: &tests-unit-changed-bundle-yrisk
        name:  Run Changed Unit Tests - Bundle (yrisk)
        caches:
          - pip
        script:
          - BUNDLE=yrisk
          # remove placeholder file to prevent unneccesary artifact creation
          - rm -f test-reports/pipeline_init.txt
          # if no bundle updates then exit
          - |
            if ! ls updates/*_updated_${BUNDLE}.txt 1> /dev/null 2>&1; then
              exit 0
            fi
          # updates occurred to test, continue
          # add root user installed python packages to system path
          - export PATH=$PATH:/root/.local/bin
          # install requirements
          - pip install --user -r requirements.txt
          # create single file with lambda names to run tests for
          - cat updates/*_${BUNDLE}.txt > lambdas_updated.txt
          # run tests for lambdas - if test lambda then run parent lambda tests
          # update corresponding test-lambda first
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                python -m arcimoto_lambda_utility update $line
              else
                python -m arcimoto_lambda_utility update test_$line
              fi
            done
          # then run tests
          - |
            while IFS= read -r line; do
              if [[ $line == test_* ]]; then
                lambda_name=${line#test_}
                if grep -Fxq "$lambda_name" updates/*; then
                  :
                else
                  python -m arcimoto_lambda_utility test $lambda_name --output-xml
                fi
              else
                python -m arcimoto_lambda_utility test $line --output-xml
              fi
            done < lambdas_updated.txt
          # tests-output folder carried to other steps to prevent polution from tests auto-detection
          - cp -a test-reports/. tests-output
        artifacts:
          - tests-output/**

pipelines:
  pull-requests:
    'MAINT-arcimoto-lambda-global-dependencies-*':
      - parallel:
        - step: *structure-create-diffs
        - step: *structure-create-tests
      # mark all lambdas as updated
      - step: *dependencies-changed-global
      # deploy all lambdas to dev
      - parallel:
        - step: *lambdas-deploy-all-bundle-alarms
        - step: *lambdas-deploy-all-bundle-authorities
        - step: *lambdas-deploy-all-bundle-backfill
        - step: *lambdas-deploy-all-bundle-debug
        - step: *lambdas-deploy-all-bundle-firmware
        - step: *lambdas-deploy-all-bundle-fleets
        - step: *lambdas-deploy-all-bundle-grafana
        - step: *lambdas-deploy-all-bundle-hologram
        - step: *lambdas-deploy-all-bundle-locations
        - step: *lambdas-deploy-all-bundle-managed_session
        - step: *lambdas-deploy-all-bundle-notes
        - step: *lambdas-deploy-all-bundle-orders
        - step: *lambdas-deploy-all-bundle-recalls
        - step: *lambdas-deploy-all-bundle-reef
        - step: *lambdas-deploy-all-bundle-replicate
        - step: *lambdas-deploy-all-bundle-sheer_id
        - step: *lambdas-deploy-all-bundle-telemetry
        - step: *lambdas-deploy-all-bundle-unit_test
        - step: *lambdas-deploy-all-bundle-userpool
        - step: *lambdas-deploy-all-bundle-users
        - step: *lambdas-deploy-all-bundle-utility
        - step: *lambdas-deploy-all-bundle-vehicles
        - step: *lambdas-deploy-all-bundle-yrisk
      # run all unit tests
      - parallel: # run unit tests for each bundle
        - step: *tests-unit-all-bundle-alarms
        - step: *tests-unit-all-bundle-authorities
        - step: *tests-unit-all-bundle-backfill
        - step: *tests-unit-all-bundle-debug
        - step: *tests-unit-all-bundle-firmware
        - step: *tests-unit-all-bundle-fleets
        - step: *tests-unit-all-bundle-grafana
        - step: *tests-unit-all-bundle-hologram
        - step: *tests-unit-all-bundle-locations
        - step: *tests-unit-all-bundle-managed_session
        - step: *tests-unit-all-bundle-notes
        - step: *tests-unit-all-bundle-orders
        - step: *tests-unit-all-bundle-recalls
        - step: *tests-unit-all-bundle-reef
        - step: *tests-unit-all-bundle-replicate
        - step: *tests-unit-all-bundle-sheer_id
        - step: *tests-unit-all-bundle-telemetry
        - step: *tests-unit-all-bundle-unit_test
        - step: *tests-unit-all-bundle-userpool
        - step: *tests-unit-all-bundle-users
        - step: *tests-unit-all-bundle-utility
        - step: *tests-unit-all-bundle-vehicles
        - step: *tests-unit-all-bundle-yrisk
      - step: *output-file-create
      - parallel: # finish
        - step: *email-tests-complete
        - step: *build-fail-if-any-test-failures

    'TEL-*':
      # create initial structure/files for use in subsequent steps
      - parallel:
        - step: *branch-set-source-head
        - step: *branch-set-destination-pr-destination
        - step: *structure-create-diffs
        - step: *structure-create-tests
      # test JSON files before using in subsequent dependencies checks
      # test suite: check dependencies.json for JSON validity
      - step: *check-dependencies-changed-global
      - step: *tests-dependencies-json
      # test suite:
      # - check each bundle's bundle.json for existence, JSON validity and schema validity
      # - check dependencies.json for schema validity
      - step: *tests-lambda-definitions
      # lambdas and dependencies changed/updated checks
      - parallel:
        - step: *check-dependencies-changed-bundles
        - step: *check-dependencies-updated-bundles
        - step: *lambdas-updated-bundle-alarms
        - step: *lambdas-updated-bundle-authorities
        - step: *lambdas-updated-bundle-backfill
        - step: *lambdas-updated-bundle-debug
        - step: *lambdas-updated-bundle-firmware
        - step: *lambdas-updated-bundle-fleets
        - step: *lambdas-updated-bundle-grafana
        - step: *lambdas-updated-bundle-hologram
        - step: *lambdas-updated-bundle-locations
        - step: *lambdas-updated-bundle-managed_session
        - step: *lambdas-updated-bundle-notes
        - step: *lambdas-updated-bundle-orders
        - step: *lambdas-updated-bundle-recalls
        - step: *lambdas-updated-bundle-reef
        - step: *lambdas-updated-bundle-replicate
        - step: *lambdas-updated-bundle-sheer_id
        - step: *lambdas-updated-bundle-telemetry
        - step: *lambdas-updated-bundle-unit_test
        - step: *lambdas-updated-bundle-userpool
        - step: *lambdas-updated-bundle-users
        - step: *lambdas-updated-bundle-utility
        - step: *lambdas-updated-bundle-vehicles
        - step: *lambdas-updated-bundle-yrisk
      # deploy changed lambdas to dev to assure later tests valid
      - parallel:
        - step: *lambdas-deploy-changed-bundle-alarms
        - step: *lambdas-deploy-changed-bundle-authorities
        - step: *lambdas-deploy-changed-bundle-backfill
        - step: *lambdas-deploy-changed-bundle-debug
        - step: *lambdas-deploy-changed-bundle-firmware
        - step: *lambdas-deploy-changed-bundle-fleets
        - step: *lambdas-deploy-changed-bundle-grafana
        - step: *lambdas-deploy-changed-bundle-hologram
        - step: *lambdas-deploy-changed-bundle-locations
        - step: *lambdas-deploy-changed-bundle-managed_session
        - step: *lambdas-deploy-changed-bundle-notes
        - step: *lambdas-deploy-changed-bundle-orders
        - step: *lambdas-deploy-changed-bundle-recalls
        - step: *lambdas-deploy-changed-bundle-reef
        - step: *lambdas-deploy-changed-bundle-replicate
        - step: *lambdas-deploy-changed-bundle-sheer_id
        - step: *lambdas-deploy-changed-bundle-telemetry
        - step: *lambdas-deploy-changed-bundle-unit_test
        - step: *lambdas-deploy-changed-bundle-userpool
        - step: *lambdas-deploy-changed-bundle-users
        - step: *lambdas-deploy-changed-bundle-utility
        - step: *lambdas-deploy-changed-bundle-vehicles
        - step: *lambdas-deploy-changed-bundle-yrisk
      # run tests
      - parallel: # run unit tests for each bundle
        - step: *tests-unit-changed-bundle-alarms
        - step: *tests-unit-changed-bundle-authorities
        - step: *tests-unit-changed-bundle-backfill
        - step: *tests-unit-changed-bundle-debug
        - step: *tests-unit-changed-bundle-firmware
        - step: *tests-unit-changed-bundle-fleets
        - step: *tests-unit-changed-bundle-grafana
        - step: *tests-unit-changed-bundle-hologram
        - step: *tests-unit-changed-bundle-locations
        - step: *tests-unit-changed-bundle-managed_session
        - step: *tests-unit-changed-bundle-notes
        - step: *tests-unit-changed-bundle-orders
        - step: *tests-unit-changed-bundle-recalls
        - step: *tests-unit-changed-bundle-reef
        - step: *tests-unit-changed-bundle-replicate
        - step: *tests-unit-changed-bundle-sheer_id
        - step: *tests-unit-changed-bundle-telemetry
        - step: *tests-unit-changed-bundle-unit_test
        - step: *tests-unit-changed-bundle-userpool
        - step: *tests-unit-changed-bundle-users
        - step: *tests-unit-changed-bundle-utility
        - step: *tests-unit-changed-bundle-vehicles
        - step: *tests-unit-changed-bundle-yrisk
      - step: *output-file-create
      - parallel: # finish
        - step: *email-tests-complete
        - step: *build-fail-if-any-test-failures

  branches:
    dev:
      # create initial structure/files for use in subsequent steps
      - parallel:
        - step: *branch-set-source-head-1
        - step: *branch-set-destination-head
        - step: *structure-create-diffs
      # lambdas and dependencies changed/updated checks
      - step: *check-dependencies-changed-global
      - parallel:
        - step: *check-dependencies-changed-bundles
        - step: *check-dependencies-updated-bundles
        - step: *lambdas-updated-bundle-alarms
        - step: *lambdas-updated-bundle-authorities
        - step: *lambdas-updated-bundle-backfill
        - step: *lambdas-updated-bundle-debug
        - step: *lambdas-updated-bundle-firmware
        - step: *lambdas-updated-bundle-fleets
        - step: *lambdas-updated-bundle-grafana
        - step: *lambdas-updated-bundle-hologram
        - step: *lambdas-updated-bundle-locations
        - step: *lambdas-updated-bundle-managed_session
        - step: *lambdas-updated-bundle-notes
        - step: *lambdas-updated-bundle-orders
        - step: *lambdas-updated-bundle-recalls
        - step: *lambdas-updated-bundle-reef
        - step: *lambdas-updated-bundle-replicate
        - step: *lambdas-updated-bundle-sheer_id
        - step: *lambdas-updated-bundle-telemetry
        - step: *lambdas-updated-bundle-unit_test
        - step: *lambdas-updated-bundle-userpool
        - step: *lambdas-updated-bundle-users
        - step: *lambdas-updated-bundle-utility
        - step: *lambdas-updated-bundle-vehicles
        - step: *lambdas-updated-bundle-yrisk
      # deploy ses templates
      - parallel:
        - step: *ses-update-template-orders-success-customer-dev
        - step: *ses-update-template-orders-success-cx-dev
      # deploy lambdas to dev
      - parallel:
        - step: *lambdas-deploy-changed-bundle-alarms
        - step: *lambdas-deploy-changed-bundle-authorities
        - step: *lambdas-deploy-changed-bundle-backfill
        - step: *lambdas-deploy-changed-bundle-debug
        - step: *lambdas-deploy-changed-bundle-firmware
        - step: *lambdas-deploy-changed-bundle-fleets
        - step: *lambdas-deploy-changed-bundle-grafana
        - step: *lambdas-deploy-changed-bundle-hologram
        - step: *lambdas-deploy-changed-bundle-locations
        - step: *lambdas-deploy-changed-bundle-managed_session
        - step: *lambdas-deploy-changed-bundle-notes
        - step: *lambdas-deploy-changed-bundle-orders
        - step: *lambdas-deploy-changed-bundle-recalls
        - step: *lambdas-deploy-changed-bundle-reef
        - step: *lambdas-deploy-changed-bundle-replicate
        - step: *lambdas-deploy-changed-bundle-sheer_id
        - step: *lambdas-deploy-changed-bundle-telemetry
        - step: *lambdas-deploy-changed-bundle-unit_test
        - step: *lambdas-deploy-changed-bundle-userpool
        - step: *lambdas-deploy-changed-bundle-users
        - step: *lambdas-deploy-changed-bundle-utility
        - step: *lambdas-deploy-changed-bundle-vehicles
        - step: *lambdas-deploy-changed-bundle-yrisk
      - step: *output-file-create
      - step: *email-release-complete-dev

    staging:
      # create initial structure/files for use in subsequent steps
      - parallel:
        - step: *branch-set-source-head-1
        - step: *branch-set-destination-head
        - step: *structure-create-diffs
      # lambdas and dependencies changed/updated checks
      - step: *check-dependencies-changed-global
      - parallel:
        - step: *check-dependencies-changed-bundles
        - step: *check-dependencies-updated-bundles
        - step: *lambdas-updated-bundle-alarms
        - step: *lambdas-updated-bundle-authorities
        - step: *lambdas-updated-bundle-backfill
        - step: *lambdas-updated-bundle-debug
        - step: *lambdas-updated-bundle-firmware
        - step: *lambdas-updated-bundle-fleets
        - step: *lambdas-updated-bundle-grafana
        - step: *lambdas-updated-bundle-hologram
        - step: *lambdas-updated-bundle-locations
        - step: *lambdas-updated-bundle-managed_session
        - step: *lambdas-updated-bundle-notes
        - step: *lambdas-updated-bundle-orders
        - step: *lambdas-updated-bundle-recalls
        - step: *lambdas-updated-bundle-reef
        - step: *lambdas-updated-bundle-replicate
        - step: *lambdas-updated-bundle-sheer_id
        - step: *lambdas-updated-bundle-telemetry
        - step: *lambdas-updated-bundle-unit_test
        - step: *lambdas-updated-bundle-userpool
        - step: *lambdas-updated-bundle-users
        - step: *lambdas-updated-bundle-utility
        - step: *lambdas-updated-bundle-vehicles
        - step: *lambdas-updated-bundle-yrisk
      # deploy ses templates
      - parallel:
        - step: *ses-update-template-orders-success-customer-staging
        - step: *ses-update-template-orders-success-cx-staging
      # release lambdas to staging
      - parallel:
        - step: *lambdas-release-staging-bundle-alarms
        - step: *lambdas-release-staging-bundle-authorities
        - step: *lambdas-release-staging-bundle-backfill
        - step: *lambdas-release-staging-bundle-debug
        - step: *lambdas-release-staging-bundle-firmware
        - step: *lambdas-release-staging-bundle-fleets
        - step: *lambdas-release-staging-bundle-grafana
        - step: *lambdas-release-staging-bundle-hologram
        - step: *lambdas-release-staging-bundle-locations
        - step: *lambdas-release-staging-bundle-managed_session
        - step: *lambdas-release-staging-bundle-notes
        - step: *lambdas-release-staging-bundle-orders
        - step: *lambdas-release-staging-bundle-recalls
        - step: *lambdas-release-staging-bundle-reef
        - step: *lambdas-release-staging-bundle-replicate
        - step: *lambdas-release-staging-bundle-sheer_id
        - step: *lambdas-release-staging-bundle-telemetry
        - step: *lambdas-release-staging-bundle-unit_test
        - step: *lambdas-release-staging-bundle-userpool
        - step: *lambdas-release-staging-bundle-users
        - step: *lambdas-release-staging-bundle-utility
        - step: *lambdas-release-staging-bundle-vehicles
        - step: *lambdas-release-staging-bundle-yrisk
      - step: *output-file-create
      - step: *email-release-complete-staging

    master:
      # create initial structure/files for use in subsequent steps
      - parallel:
        - step: *branch-set-source-head-1
        - step: *branch-set-destination-head
        - step: *structure-create-diffs
      # lambdas and dependencies changed/updated checks
      - step: *check-dependencies-changed-global
      - parallel:
        - step: *check-dependencies-changed-bundles
        - step: *check-dependencies-updated-bundles
        - step: *lambdas-updated-bundle-alarms
        - step: *lambdas-updated-bundle-authorities
        - step: *lambdas-updated-bundle-backfill
        - step: *lambdas-updated-bundle-debug
        - step: *lambdas-updated-bundle-firmware
        - step: *lambdas-updated-bundle-fleets
        - step: *lambdas-updated-bundle-grafana
        - step: *lambdas-updated-bundle-hologram
        - step: *lambdas-updated-bundle-locations
        - step: *lambdas-updated-bundle-managed_session
        - step: *lambdas-updated-bundle-notes
        - step: *lambdas-updated-bundle-orders
        - step: *lambdas-updated-bundle-recalls
        - step: *lambdas-updated-bundle-reef
        - step: *lambdas-updated-bundle-replicate
        - step: *lambdas-updated-bundle-sheer_id
        - step: *lambdas-updated-bundle-telemetry
        - step: *lambdas-updated-bundle-unit_test
        - step: *lambdas-updated-bundle-userpool
        - step: *lambdas-updated-bundle-users
        - step: *lambdas-updated-bundle-utility
        - step: *lambdas-updated-bundle-vehicles
        - step: *lambdas-updated-bundle-yrisk
      # deploy ses templates
      - parallel:
        - step: *ses-update-template-orders-success-customer-prod
        - step: *ses-update-template-orders-success-cx-prod
      # release lambdas to prod
      - parallel:
        - step: *lambdas-release-prod-bundle-alarms
        - step: *lambdas-release-prod-bundle-authorities
        - step: *lambdas-release-prod-bundle-backfill
        - step: *lambdas-release-prod-bundle-debug
        - step: *lambdas-release-prod-bundle-firmware
        - step: *lambdas-release-prod-bundle-fleets
        - step: *lambdas-release-prod-bundle-grafana
        - step: *lambdas-release-prod-bundle-hologram
        - step: *lambdas-release-prod-bundle-locations
        - step: *lambdas-release-prod-bundle-managed_session
        - step: *lambdas-release-prod-bundle-notes
        - step: *lambdas-release-prod-bundle-orders
        - step: *lambdas-release-prod-bundle-recalls
        - step: *lambdas-release-prod-bundle-reef
        - step: *lambdas-release-prod-bundle-replicate
        - step: *lambdas-release-prod-bundle-sheer_id
        - step: *lambdas-release-prod-bundle-telemetry
        - step: *lambdas-release-prod-bundle-unit_test
        - step: *lambdas-release-prod-bundle-userpool
        - step: *lambdas-release-prod-bundle-users
        - step: *lambdas-release-prod-bundle-utility
        - step: *lambdas-release-prod-bundle-vehicles
        - step: *lambdas-release-prod-bundle-yrisk
      - step: *output-file-create
      - step: *email-release-complete-prod